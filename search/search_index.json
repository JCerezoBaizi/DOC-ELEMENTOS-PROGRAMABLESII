{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"Practica7/","title":"WiFi - Encender Leds","text":""},{"location":"Practica7/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Control de LEDs con ESP32 v\u00eda Servidor Web </li> <li>Equipo / Autor(es): Jesus Cerezo - Karen Najera </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 22/09/25 </li> <li>Descripci\u00f3n breve: Este proyecto utiliza un microcontrolador ESP32 conectado a WiFi para crear un servidor web que permite encender y apagar tres LEDs a trav\u00e9s de una interfaz en el navegador. Demuestra los principios de redes, servidores HTTP y control de salidas digitales en sistemas embebidos.</li> </ul>"},{"location":"Practica7/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Desarrollar un sistema de control remoto utilizando un ESP32 que, mediante un servidor web, permita encender y apagar m\u00faltiples LEDs desde cualquier dispositivo conectado a la misma red WiFi.</li> <li>Espec\u00edficos:</li> <li>Configurar la conexi\u00f3n WiFi del ESP32 para establecer comunicaci\u00f3n con la red y generar una direcci\u00f3n IP accesible desde un navegador</li> <li>Implementar un servidor web en el ESP32 que interprete solicitudes HTTP y ejecute acciones sobre los pines digitales asociados a los LEDs.</li> <li>Dise\u00f1ar una interfaz web sencilla que muestre el estado de los LEDs y permita controlarlos en tiempo real.</li> </ul>"},{"location":"Practica7/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye<ul> <li>Controlar tres LEDs de forma remota mediante un servidor web alojado en el ESP32.</li> <li>Demostrar la integraci\u00f3n de red WiFi, servidor HTTP e interacci\u00f3n con hardware digital.</li> </ul> </li> <li>Excluye<ul> <li>No se implementa interfaz gr\u00e1fica avanzada, solo una p\u00e1gina web b\u00e1sica.</li> <li>No incluye control desde fuera de la red local</li> </ul> </li> </ul>"},{"location":"Practica7/#3-requisitos","title":"3) Requisitos","text":"<ul> <li>Software<ul> <li>Arduino IDE</li> <li>Navegador web en un dispositivo conectado a la misma red WiFi que el ESP32.</li> </ul> </li> <li>Hardware<ul> <li>ESP32</li> <li>Protoboard</li> <li>3 LEDS</li> <li>3 Resistencias</li> <li>Cables jumper</li> <li>Cable USB</li> </ul> </li> </ul> <p>-Requisitos de funcionamiento) - El ESP32 debe conectarse correctamente a la red WiFi configurada.- El servidor web debe levantar en el puerto 80 y mostrar una p\u00e1gina accesible desde la IP del ESP32. - La interfaz web debe permitir encender y apagar los LEDs remotamente. - El sistema debe reflejar el estado real de cada LED (ON/OFF) en la p\u00e1gina. - El control es local</p> <p>Conocimientos previos - HTML b\u00e1sico - Electr\u00f3nica b\u00e1sica - Programaci\u00f3n en Arduino/ESP32</p>"},{"location":"Proyectofinal/","title":"Proyecto Final ESP32 \u2013 Plataforma Stewart","text":""},{"location":"Proyectofinal/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Control de plataforma Stewart con ESP32 y visi\u00f3n por computadora </li> <li>Equipo / Autor(es): Jesus Cerezo - Emmanuel Angeles-Ximena Verdi </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 08/12/25 </li> <li>Descripci\u00f3n breve: Este proyecto controla una pelota sobre una plataforma tipo Stewart utilizando tres servomotores manejados por un ESP32. La inclinaci\u00f3n de la base se controla con el movimiento de la mano, detectado mediante c\u00e1mara y MediaPipe, y los \u00e1ngulos se env\u00edan al ESP32 por Bluetooth para posicionar suavemente la plataforma.</li> </ul>"},{"location":"Proyectofinal/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Desarrollar un sistema de control de plataforma tipo Stewart utilizando un ESP32 y visi\u00f3n por computadora, que permita mover una pelota mediante la inclinaci\u00f3n de la mano del usuario.</p> </li> <li> <p>Espec\u00edficos:</p> </li> <li>Configurar un ESP32 para controlar tres servomotores mediante PWM y comunicaci\u00f3n Bluetooth.</li> <li>Implementar en Python la detecci\u00f3n de mano con MediaPipe para obtener inclinaciones tipo pitch y roll.</li> <li>Mapear los movimientos de la mano a \u00e1ngulos de servos y enviarlos al ESP32 en tiempo real.</li> <li>Dise\u00f1ar e imprimir en 3D la estructura mec\u00e1nica (base, brazos y uniones) para soportar la plataforma.</li> </ul>"},{"location":"Proyectofinal/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:</li> <li>Control en tiempo real de tres servomotores con rampas suaves de movimiento.</li> <li>Comunicaci\u00f3n Bluetooth entre computadora (Python) y ESP32.</li> <li>Detecci\u00f3n de mano con c\u00e1mara web usando MediaPipe.</li> <li> <p>Dise\u00f1o e impresi\u00f3n 3D de la base y brazos de la plataforma.</p> </li> <li> <p>Excluye:</p> </li> <li>Control desde Internet o redes externas (solo conexi\u00f3n local Bluetooth).</li> <li>Control autom\u00e1tico sin intervenci\u00f3n de la mano (no hay algoritmo aut\u00f3nomo de estabilizaci\u00f3n).</li> <li>Modelos din\u00e1micos avanzados de la pelota (se trabaja de forma experimental).</li> </ul>"},{"location":"Proyectofinal/#4-requisitos","title":"4) Requisitos","text":"<ul> <li>Software</li> <li>Arduino IDE</li> <li>Visual Studio Code (o editor equivalente)</li> <li>Python 3.x</li> <li> <p>Librer\u00edas de Python:</p> <ul> <li><code>opencv-python</code></li> <li><code>mediapipe</code></li> <li><code>bluetooth</code> (PyBluez u otra implementaci\u00f3n compatible)</li> </ul> </li> <li> <p>Hardware</p> </li> <li>ESP32</li> <li>3 servomotores</li> <li>Protoboard</li> <li>Cables jumper</li> <li>Fuente de alimentaci\u00f3n (por ejemplo 5 V para servos)</li> <li>Cable USB para programar el ESP32</li> <li>Estructura mec\u00e1nica impresa en 3D (base, brazos, uniones)</li> <li> <p>Tornillos tipo M3, tuercas y rondanas</p> </li> <li> <p>Requisitos de funcionamiento</p> </li> <li>El ESP32 debe emparejarse correctamente por Bluetooth con la computadora.</li> <li>El script de Python debe detectar la mano y generar \u00e1ngulos dentro del rango 0\u00b0\u2013180\u00b0.</li> <li>El ESP32 debe recibir los comandos de texto y mover los servos con rampas suaves.</li> <li>Ante la p\u00e9rdida de comunicaci\u00f3n, la plataforma debe regresar a una posici\u00f3n segura (HOME).</li> </ul>"},{"location":"Proyectofinal/#5-diseno-modelos-3d","title":"5) Dise\u00f1o / Modelos 3D","text":""},{"location":"Proyectofinal/#base-central","title":"Base central","text":""},{"location":"Proyectofinal/#brazo-intermedio","title":"Brazo intermedio","text":""},{"location":"Proyectofinal/#conector-superior-cuadrito","title":"Conector superior (\u201ccuadrito\u201d)","text":""},{"location":"Proyectofinal/#horn-del-servo","title":"Horn del servo","text":""},{"location":"Proyectofinal/#6-codigo-fuente-python-arduino-en-un-solo-bloque","title":"6) C\u00f3digo fuente (Python + Arduino en un solo bloque)","text":"<pre><code>import cv2\nimport mediapipe as mp\nimport time\nimport bluetooth\n\n# ================== CONEXI\u00d3N BLUETOOTH ==================\n\nPORT = 1\nESP32_MAC = \"14:33:5C:02:4D:2A\"   # CAMBIA a la MAC de tu ESP32\n\nsock = bluetooth.BluetoothSocket()\nsock.settimeout(20)\n\nprint(\"Intentando conectar al ESP32...\")\nwhile True:\n    try:\n        sock.connect((ESP32_MAC, PORT))\n        print(\"\u00a1Conectado al ESP32!\")\n        break\n    except Exception as e:\n        print(\"Error en conexi\u00f3n... reintentando:\", e)\n        time.sleep(1)\n\ndef send_bt(message: str):\n    try:\n        sock.send(message.encode())\n        print(\"Enviado:\", message.strip())\n    except:\n        print(\"Error enviando datos\")\n\n\n# ================== MEDIAPIPE ==================\n\nmp_hands = mp.solutions.hands\nhands = mp_hands.Hands(max_num_hands=1,\n                       min_detection_confidence=0.6,\n                       min_tracking_confidence=0.5)\nmp_draw = mp.solutions.drawing_utils\n\ncap = cv2.VideoCapture(0)\n\n# ===== FILTROS =====\npitch_filtrado = 0\nroll_filtrado = 0\nalpha = 0.25\n\nultimo_envio = time.time()\nintervalo_envio = 0.05\n\n# ===== HOME =====\nHOME_IZQ = 90\nHOME_ARRIBA = 90\nHOME_DER = 90\n\n# ===== GANANCIAS =====\nK_pitch = 30.0\nK_roll  = 0.05\nK_lat   = 85.0\nK_mid_acompa = 20.0\n\n\nwhile cap.isOpened():\n\n    ret, img = cap.read()\n    if not ret:\n        break\n\n    img = cv2.flip(img, 1)\n    rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    results = hands.process(rgb)\n    h, w, _ = img.shape\n\n    detectada = False\n\n    if results.multi_hand_landmarks:\n        for hand in results.multi_hand_landmarks:\n            detectada = True\n            mp_draw.draw_landmarks(img, hand, mp_hands.HAND_CONNECTIONS)\n\n            # coordenadas importantes\n            muneca = hand.landmark[0]\n            medio  = hand.landmark[12]\n            pulgar = hand.landmark[4]\n\n            wx, wy = int(muneca.x*w), int(muneca.y*h)\n            mx, my = int(medio.x*w),  int(medio.y*h)\n            px, py = int(pulgar.x*w), int(pulgar.y*h)\n\n            cv2.circle(img, (wx,wy), 10, (255,0,0), -1)\n            cv2.circle(img, (mx,my), 10, (0,255,0), -1)\n            cv2.circle(img, (px,py), 10, (0,0,255), -1)\n\n            # ---------- c\u00e1lculos ----------\n            pitch = (muneca.z - medio.z) * 1.8\n            pitch = max(-1, min(1, pitch))\n\n            dy = wy - py\n            roll = dy * K_roll\n            roll = max(-1, min(1, roll))\n\n            pitch_filtrado = (1-alpha)*pitch_filtrado + alpha*pitch\n            roll_filtrado  = (1-alpha)*roll_filtrado  + alpha*roll\n\n            if abs(pitch_filtrado) &lt; 0.05:\n                pitch_filtrado = 0\n            if abs(roll_filtrado) &lt; 0.05:\n                roll_filtrado = 0\n\n            # ---------- servos ----------\n            # centro\n            a_arriba = HOME_ARRIBA + K_pitch*pitch_filtrado + K_mid_acompa*abs(roll_filtrado)\n\n            # laterales\n            delta_lat = K_lat * roll_filtrado\n            a_izq = HOME_IZQ - delta_lat\n            a_der = HOME_DER + delta_lat\n\n            # acompa\u00f1amiento pitch\n            a_izq += (K_pitch*0.25)*pitch_filtrado\n            a_der += (K_pitch*0.25)*pitch_filtrado\n\n            # l\u00edmites\n            a_izq = int(max(0, min(180, a_izq)))\n            a_arriba = int(max(0, min(180, a_arriba)))\n            a_der = int(max(0, min(180, a_der)))\n\n            # enviar\n            if time.time() - ultimo_envio &gt;= intervalo_envio:\n                msg = f\"ANG:{a_izq},{a_arriba},{a_der}\\n\"\n                send_bt(msg)\n                ultimo_envio = time.time()\n\n    if not detectada:\n        cv2.putText(img, \"No se detecta mano\", (10,30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n    cv2.imshow(\"STEWART CONTROL PULGAR\", img)\n\n    k = cv2.waitKey(1)\n    if k == ord('q'):\n        break\n    if k == ord('z') or k == ord('c'):\n        send_bt(\"ZERO\\n\")\n\nsock.close()\ncap.release()\ncv2.destroyAllWindows()\nprint(\"Programa terminado\")\n\n#include &lt;Arduino.h&gt;\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n// ===== Buffer para lectura BT no bloqueante =====\nString btBuffer;\n\n// ===== Pines de los servos =====\n#define SERVO_IZQ    15   // Servo izquierdo\n#define SERVO_ARRIBA 33   // Servo central / vertical\n#define SERVO_DER    25   // Servo derecho\n\n// ===== \u00c1NGULOS HOME =====\nconst int HOME_IZQ    = 90;\nconst int HOME_ARRIBA = 90;\nconst int HOME_DER    = 90;\n\n// ===== PWM =====\nconst uint32_t FREQ_HZ   = 50;\nconst uint8_t  RES_BITS  = 12;\nconst uint16_t DUTY_MIN  = 205;   // ~1.0 ms (\u22480\u00b0)\nconst uint16_t DUTY_MAX  = 410;   // ~2.0 ms (\u2248180\u00b0)\n\n// Convierte grados f\u00edsicos 0..180 a duty\nuint16_t dutyFromDeg(int deg) {\n  deg = constrain(deg, 0, 180);\n  return map(deg, 0, 180, DUTY_MIN, DUTY_MAX);\n}\n\n// Convierte de \u00e1ngulo l\u00f3gico (0..180) a f\u00edsico (invertido)\nint logicalToPhysical(int logicalDeg) {\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  return 180 - logicalDeg;  // invertido\n}\n\n// Escribe usando grados L\u00d3GICOS\nvoid writeServoLogical(int pin, int logicalDeg) {\n  int fisico = logicalToPhysical(logicalDeg);\n  ledcWrite(pin, dutyFromDeg(fisico));\n}\n\n// Configurar servo con \u00e1ngulo l\u00f3gico inicial\nvoid configServo(int pin, int initialLogical) {\n  pinMode(pin, OUTPUT);\n  ledcAttach(pin, FREQ_HZ, RES_BITS);   // en core 3.x el pin ES el canal\n  writeServoLogical(pin, initialLogical);\n}\n\n// ===== Rampa =====\nconst int  LIM_MIN     = 0;\nconst int  LIM_MAX     = 180;\nconst int  PASO_RAMPA  = 5;\nconst uint32_t DT_RAMP = 10;\nconst uint32_t TIMEOUT_MS = 700;\n\n// Estado actual l\u00f3gicos\nint posIzq    = HOME_IZQ;\nint posArriba = HOME_ARRIBA;\nint posDer    = HOME_DER;\n\n// Objetivos\nint tgtIzq    = HOME_IZQ;\nint tgtArriba = HOME_ARRIBA;\nint tgtDer    = HOME_DER;\n\nuint32_t tPrevRamp = 0;\nuint32_t tLastCmd  = 0;\n\n// Rampa suave\nvoid aplicarRampa() {\n  uint32_t now = millis();\n  if (now - tPrevRamp &lt; DT_RAMP) return;\n  tPrevRamp = now;\n\n  auto go = [&amp;](int actual, int target){\n    if(actual &lt; target) return min(actual + PASO_RAMPA, target);\n    if(actual &gt; target) return max(actual - PASO_RAMPA, target);\n    return actual;\n  };\n\n  posIzq    = go(posIzq,    tgtIzq);\n  posArriba = go(posArriba, tgtArriba);\n  posDer    = go(posDer,    tgtDer);\n\n  writeServoLogical(SERVO_IZQ,    posIzq);\n  writeServoLogical(SERVO_ARRIBA, posArriba);\n  writeServoLogical(SERVO_DER,    posDer);\n}\n\n// Parsea \"ANG:x,y,z\"\nbool parseAngulos(const String &amp;msg, int &amp;aIzq, int &amp;aArriba, int &amp;aDer){\n  if(!msg.startsWith(\"ANG:\")) return false;\n\n  String data = msg.substring(4);\n  int c1 = data.indexOf(',');\n  int c2 = data.indexOf(',', c1+1);\n  if(c1 &lt; 0 || c2 &lt; 0) return false;\n\n  aIzq    = data.substring(0, c1).toInt();\n  aArriba = data.substring(c1+1, c2).toInt();\n  aDer    = data.substring(c2+1).toInt();\n\n  return true;\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32-Stewart\");\n\n  configServo(SERVO_IZQ,    posIzq);\n  configServo(SERVO_ARRIBA, posArriba);\n  configServo(SERVO_DER,    posDer);\n\n  Serial.println(\"ESP32 listo - Plataforma Stewart\");\n  Serial.println(\"Pines: 15 = Izq, 33 = Arriba, 25 = Der\");\n\n  tLastCmd = millis();\n}\n\nvoid loop() {\n\n  while(SerialBT.available()) {\n    char c = (char)SerialBT.read();\n\n    if(c == '\\n') {\n      String msg = btBuffer;\n      btBuffer = \"\";\n      msg.trim();\n\n      if(msg.length() &gt; 0) {\n        tLastCmd = millis();\n\n        if(msg == \"ZERO\" || msg == \"LOST\"){\n          tgtIzq    = HOME_IZQ;\n          tgtArriba = HOME_ARRIBA;\n          tgtDer    = HOME_DER;\n          Serial.println(\"HOME ejecutado (ZERO/LOST)\");\n        }\n        else {\n          int aI, aA, aD;\n          if(parseAngulos(msg, aI, aA, aD)){\n            tgtIzq    = constrain(aI, LIM_MIN, LIM_MAX);\n            tgtArriba = constrain(aA, LIM_MIN, LIM_MAX);\n            tgtDer    = constrain(aD, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; %d, %d, %d\\n\", tgtIzq, tgtArriba, tgtDer);\n          }\n          else {\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    }\n    else if(c != '\\r') {\n      btBuffer += c;\n    }\n  }\n\n  if(millis() - tLastCmd &gt; TIMEOUT_MS){\n    tgtIzq    = HOME_IZQ;\n    tgtArriba = HOME_ARRIBA;\n    tgtDer    = HOME_DER;\n  }\n\n  aplicarRampa();\n  delay(1);\n}\n</code></pre>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"practica1/","title":"\ud83d\udcda Pr\u00e1ctica 1 - NeoPixel_B\u00e1sico","text":"<p>El programa crea un efecto de parpedeo infinito de algun color que sepamos su \"rgb\", donde las personas no alcanzamos a distinguir. Ocupamos conceptos b\u00e1sicos de control de  LEDs RGB y temporizaci\u00f3n con delays. Es ideal si no comprendes el funcionamiento de los NeoPixels. </p>"},{"location":"practica1/#1-resumen","title":"1) Resum\u00e9n \ud83d\udccc","text":"<ul> <li>Equipo / Autor(es): ANGELES BARRETO EMMANUEL, CEREZO PONCE JESUS ALFREDO</li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 25/08/25  </li> </ul>"},{"location":"practica1/#2-codigo","title":"2) C\u00f3digo \u2328","text":"<p>bash</p>"},{"location":"practica1/#_1","title":"========================================","text":"<p>#LIBRER\u00cdAS NECESARIAS</p>"},{"location":"practica1/#_2","title":"========================================","text":"<p>#Desde el primer include hasta el \"define\" llevan # include   // Librer\u00eda para controlar LEDs NeoPixel RGB direccionables ifdef AVR    include   // Librer\u00eda espec\u00edfica para placas AVR (optimizaci\u00f3n de energ\u00eda) endif <p>#========================================  #CONFIGURACI\u00d3N DE CONSTANTES  #======================================== define PIN  8          // Pin digital del ESP32 donde est\u00e1 conectado el LED NeoPixel define NUMPIXELS 1     // Cantidad total de LEDs en la tira (en este caso solo 1)</p>"},{"location":"practica1/#_3","title":"========================================","text":""},{"location":"practica1/#inicializacion-del-objeto-neopixel","title":"INICIALIZACI\u00d3N DEL OBJETO NEOPIXEL","text":""},{"location":"practica1/#_4","title":"========================================","text":""},{"location":"practica1/#parametros-cantidad-de-leds-pin-de-datos-tipo-de-led-grb-frecuencia-800khz","title":"Par\u00e1metros: cantidad de LEDs, pin de datos, tipo de LED (GRB) + frecuencia (800KHz)","text":"<p>Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);</p>"},{"location":"practica1/#_5","title":"========================================","text":""},{"location":"practica1/#configuracion-inicial-se-ejecuta-una-sola-vez","title":"CONFIGURACI\u00d3N INICIAL (se ejecuta una sola vez)","text":""},{"location":"practica1/#_6","title":"========================================","text":"<p>void setup(){   Serial.begin(115200);  // Inicializar comunicaci\u00f3n serial a 115200 baudios para debug   pixels.begin();        // Inicializar el sistema NeoPixel (configurar pin como salida) }</p>"},{"location":"practica1/#_7","title":"========================================","text":""},{"location":"practica1/#bucle-principal-se-ejecuta-infinitamente","title":"BUCLE PRINCIPAL (se ejecuta infinitamente)","text":""},{"location":"practica1/#_8","title":"========================================","text":"<p>void loop(){   // Paso 1: Apagar el LED (poner todos los colores en 0)   pixels.clear();</p> <p># Paso 2: Configurar el color del LED en \u00edndice 0   # Color morado: Rojo=122, Verde=0, Azul=122   # Valores van de 0 (apagado) a 255 (m\u00e1ximo brillo)   pixels.setPixelColor(0, pixels.Color(122, 0, 122));</p> <p># Paso 3: Enviar los datos al LED para que muestre el color configurado   pixels.show();</p> <p># Paso 4: Mantener el LED encendido durante 700 milisegundos (0.7 segundos)   delay(700);</p> <p># El ciclo se repite: el LED se apaga brevemente y vuelve a encender, creando un efecto de parpadeo en color morado }</p>"},{"location":"practica1/#3-evidencias-del-resultado-final","title":"3) Evidencias del resultado final \ud83d\udcf8","text":"<p>VIDEO MUESTRA YT</p>"},{"location":"practica2/","title":"\ud83d\udcda Pr\u00e1ctica 2 - Comunicaci\u00f3nSerial_NeoPixel","text":"<p>El programa controla un LED NeoPixel mediante comunicaci\u00f3n serial (Serial.begin(115200)), encendi\u00e9ndolo en color magenta (RGB: 122, 0, 122) \u00fanicamente cuando recibe un mensaje (if Serial.available() &gt; 0 y Serial.readStringUntil('\\n')). Ocupamos conceptos de control de LEDs RGB con pixels.setPixelColor() y pixels.show(), lectura de datos seriales y condicionales. Es ideal para aprender la interacci\u00f3n entre Arduino y dispositivos externos mediante el puerto serial, permitiendo activar el LED bajo demanda.</p>"},{"location":"practica2/#1-resumen","title":"1) Resum\u00e9n \ud83d\udccc","text":"<ul> <li>Equipo / Autor(es): Emmanuel Angeles Barreto</li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 23/09/25  </li> </ul>"},{"location":"practica2/#2-codigo","title":"2) C\u00f3digo \u2328","text":"<p>bash</p>"},{"location":"practica2/#desde-el-primer-include-hasta-el-ultimo-define-llevan","title":"Desde el primer include hasta el ultimo \"define\" llevan","text":""},{"location":"practica2/#_1","title":"========================================","text":""},{"location":"practica2/#codigo-2-control-de-led-neopixel-por-comunicacion-serial","title":"C\u00d3DIGO 2: CONTROL DE LED NEOPIXEL POR COMUNICACI\u00d3N SERIAL","text":""},{"location":"practica2/#_2","title":"========================================","text":""},{"location":"practica2/#desde-el-primer-include-hasta-el-ultimo-define-llevan_1","title":"Desde el primer include hasta el ultimo \"define\" llevan","text":"<p>include   // Librer\u00eda para controlar LEDs NeoPixel RGB direccionables ifdef AVR    include   // Librer\u00eda espec\u00edfica para placas AVR (optimizaci\u00f3n de energ\u00eda) endif"},{"location":"practica2/#_3","title":"========================================","text":""},{"location":"practica2/#configuracion-de-constantes","title":"CONFIGURACI\u00d3N DE CONSTANTES","text":""},{"location":"practica2/#_4","title":"========================================","text":"<p>define PIN  8          // Pin digital del ESP32 donde est\u00e1 conectado el LED NeoPixel define NUMPIXELS 1     // Cantidad total de LEDs en la tira (en este caso solo 1)</p>"},{"location":"practica2/#_5","title":"========================================","text":""},{"location":"practica2/#inicializacion-del-objeto-neopixel","title":"INICIALIZACI\u00d3N DEL OBJETO NEOPIXEL","text":""},{"location":"practica2/#_6","title":"========================================","text":""},{"location":"practica2/#parametros-cantidad-de-leds-pin-de-datos-tipo-de-led-grb-frecuencia-800khz","title":"Par\u00e1metros: cantidad de LEDs, pin de datos, tipo de LED (GRB) + frecuencia (800KHz)","text":"<p>Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);</p>"},{"location":"practica2/#_7","title":"========================================","text":""},{"location":"practica2/#configuracion-inicial-se-ejecuta-una-sola-vez","title":"CONFIGURACI\u00d3N INICIAL (se ejecuta una sola vez)","text":""},{"location":"practica2/#_8","title":"========================================","text":"<p>void setup(){   Serial.begin(115200);  // Inicializar comunicaci\u00f3n serial a 115200 baudios para recibir comandos   pixels.begin();        // Inicializar el sistema NeoPixel (configurar pin como salida) }</p>"},{"location":"practica2/#_9","title":"========================================","text":""},{"location":"practica2/#bucle-principal-se-ejecuta-infinitamente","title":"BUCLE PRINCIPAL (se ejecuta infinitamente)","text":""},{"location":"practica2/#_10","title":"========================================","text":"<p>void loop(){   # Paso 1: Verificar si hay datos disponibles en el puerto serial   if (Serial.available() &gt; 0){</p> <pre><code># Paso 2: Leer el mensaje recibido hasta encontrar un salto de l\u00ednea ('\\n')\nString msj = Serial.readStringUntil('\\n');\n\n# Paso 3: Mostrar el mensaje recibido en el Serial Monitor (retroalimentaci\u00f3n)\nSerial.println(msj);\n\n# Paso 4: Apagar el LED antes de configurar el nuevo color\npixels.clear();\n\n# Paso 5: Configurar el color del LED en \u00edndice 0\n# Color morado/magenta: Rojo=122, Verde=0, Azul=122\n# Valores van de 0 (apagado) a 255 (m\u00e1ximo brillo)\npixels.setPixelColor(0, pixels.Color(122, 0, 122));\n\n# Paso 6: Enviar los datos al LED para que muestre el color configurado\npixels.show();\n</code></pre> <p>}</p> <p># Paso 7: Esperar 700 milisegundos (0.7 segundos) antes de la siguiente iteraci\u00f3n   # Este delay se ejecuta siempre, haya o no mensaje recibido   delay(700);</p> <p># IMPORTANTE: El LED solo se enciende cuando se recibe un mensaje por el puerto serial   # Si no hay mensajes, el LED permanece en su \u00faltimo estado }</p>"},{"location":"practica2/#3-evidencias-del-resultado-final","title":"3) Evidencias del resultado final \ud83d\udcf8","text":"<p>VIDEO MUESTRA YT</p>"},{"location":"practica5/","title":"\ud83d\udcdaPRACTICA 5 - Comunicaci\u00f3n_BLE_B\u00e1sica","text":""},{"location":"practica5/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): ANGELES_BARRETO_EMMANUEL, CEREZO_PONCE_JESUS_ALFREDO  </li> <li>Curso / Asignatura: ELEMENTOS_PROGRAMABLES_II  </li> <li>Descripci\u00f3n breve: El programa configura un ESP32 como dispositivo Bluetooth Low Energy (BLE) que anuncia un servicio y una caracter\u00edstica; permite comunicaci\u00f3n b\u00e1sica con clientes BLE (smartphone, PC) para lectura/escritura de una cadena de texto.</li> </ul>"},{"location":"practica5/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Implementar la comunicaci\u00f3n inal\u00e1mbrica mediante Bluetooth Low Energy (BLE) en el ESP32, comprendiendo el proceso de creaci\u00f3n de un servidor BLE y su interacci\u00f3n con dispositivos clientes.  </p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Configurar el ESP32 como servidor BLE con un servicio personalizado.  </li> <li>Crear una caracter\u00edstica BLE con permisos de lectura y escritura.  </li> <li>Analizar el funcionamiento del modo advertising y su detecci\u00f3n por otros dispositivos.  </li> <li>Comprobar la comunicaci\u00f3n entre el ESP32 y una aplicaci\u00f3n m\u00f3vil BLE. </li> </ul>"},{"location":"practica5/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li> <p>Incluye: El desarrollo de un servidor BLE funcional utilizando el ESP32, capaz de anunciar un servicio y permitir la lectura y escritura de datos desde una aplicaci\u00f3n cliente BLE (como nRF Connect o LightBlue).  </p> </li> <li> <p>No incluye: La implementaci\u00f3n de m\u00faltiples servicios simult\u00e1neos, encriptaci\u00f3n de datos BLE, ni la integraci\u00f3n con WiFi, Internet o plataformas IoT externas.  </p> </li> </ul>"},{"location":"practica5/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Arduino IDE versi\u00f3n 2.0 o superior. - Extensi\u00f3n de tarjetas ESP32 instalada desde el Gestor de Tarjetas. - Librer\u00edas necesarias: BLEDevice.h, BLEUtils.h y BLEServer.h. - Aplicaci\u00f3n m\u00f3vil para pruebas BLE (nRF Connect, LightBlue, o similar).  </p> <p>Hardware - Microcontrolador ESP32 DevKit v1. - Cable USB para conexi\u00f3n y carga del programa. - Computadora con sistema operativo Windows, Linux o macOS.  </p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C++ y entorno Arduino. - Conceptos de comunicaci\u00f3n inal\u00e1mbrica (Bluetooth/BLE). - Uso de herramientas de monitoreo serial y escaneo BLE.  </p>"},{"location":"practica5/#5-instalacion-codigo","title":"5) Instalaci\u00f3n / C\u00f3digo \u2328","text":"<p>bash</p>"},{"location":"practica5/#_1","title":"========================================","text":""},{"location":"practica5/#librerias-necesarias","title":"LIBRER\u00cdAS NECESARIAS","text":""},{"location":"practica5/#_2","title":"========================================","text":"<p>include  include  include"},{"location":"practica5/#_3","title":"========================================","text":""},{"location":"practica5/#configuracion-principal-version-ajustada","title":"CONFIGURACI\u00d3N PRINCIPAL (versi\u00f3n ajustada)","text":""},{"location":"practica5/#_4","title":"========================================","text":"<p>static const char* DEVICE_NAME = \"AK_BLE_Node\";  # Nombre visible al escanear define SERVICE_UUID_NEW        \"87654321-4321-4321-4321-0987654321ab\" define CHARACTERISTIC_UUID_NEW \"dcba4321-8765-09ab-cdef-0123456789ab\"</p>"},{"location":"practica5/#_5","title":"========================================","text":""},{"location":"practica5/#configuracion-inicial-setup","title":"CONFIGURACI\u00d3N INICIAL (setup)","text":""},{"location":"practica5/#_6","title":"========================================","text":"<p>void setup() {   Serial.begin(115200);   delay(120);  # peque\u00f1o retardo para estabilizar el puerto serie</p> <p># Inicializa BLE con el nombre definido arriba   BLEDevice::init(DEVICE_NAME);</p> <p># Crea servidor BLE y agrega un servicio con UUID personalizado   BLEServer pServer = BLEDevice::createServer();   BLEService pService = pServer-&gt;createService(SERVICE_UUID_NEW);</p> <p># Crea una caracter\u00edstica con permisos de lectura y escritura   BLECharacteristic* pCharacteristic = pService-&gt;createCharacteristic(       CHARACTERISTIC_UUID_NEW,       BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE   );</p> <p># Valor inicial de la caracter\u00edstica (puedes cambiarlo desde un cliente BLE)   pCharacteristic-&gt;setValue(\"Hola mundo BLE\");</p> <p># Arranca el servicio para hacerlo disponible   pService-&gt;start();</p> <p># Configura el advertising para que el dispositivo sea detectable   BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();   pAdvertising-&gt;addServiceUUID(SERVICE_UUID_NEW);   # Anuncia el UUID del servicio   pAdvertising-&gt;setScanResponse(true);              # Incluir respuesta de escaneo   pAdvertising-&gt;setMinPreferred(0x06);              # Par\u00e1metros recomendados por el core   pAdvertising-&gt;setMinPreferred(0x12);</p> <p># Inicia la publicidad BLE (advertising)   BLEDevice::startAdvertising();   Serial.println(\"BLE Advertising iniciado (AK_BLE_Node)\"); }</p>"},{"location":"practica5/#_7","title":"========================================","text":""},{"location":"practica5/#bucle-principal-loop","title":"BUCLE PRINCIPAL (loop)","text":""},{"location":"practica5/#_8","title":"========================================","text":"<p>void loop() {   # El advertising funciona en background; no es necesario hacer nada aqu\u00ed   delay(1000); }</p>"},{"location":"practica5/#5-conclusion","title":"5) Conclusi\u00f3n \ud83e\udde0","text":"<p>En esta pr\u00e1ctica se logr\u00f3 implementar un servidor Bluetooth Low Energy (BLE) en el ESP32, comprendiendo el proceso de inicializaci\u00f3n, creaci\u00f3n de servicios y caracter\u00edsticas, as\u00ed como la transmisi\u00f3n de informaci\u00f3n mediante el modo advertising. Se verific\u00f3 la conexi\u00f3n con dispositivos externos y la capacidad del microcontrolador para actuar como un servidor BLE estable y de bajo consumo, lo cual es esencial en aplicaciones de IoT, monitoreo inal\u00e1mbrico y sistemas port\u00e1tiles inteligentes. Esta pr\u00e1ctica refuerza los fundamentos de la comunicaci\u00f3n inal\u00e1mbrica moderna y sienta las bases para proyectos m\u00e1s complejos que integren BLE con sensores y plataformas m\u00f3viles.</p>"}]}